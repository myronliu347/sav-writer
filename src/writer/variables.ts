import * as moment from 'moment';
import { buffer, BufferType } from '../utilities';

export enum alignments {
  Centre = 2,
  Left = 0,
  Right = 1,
}

export enum measures {
  Continuous = 3,
  Nominal = 1,
  Ordinal = 2,
}

export enum types {
  Date = 20,
  DateTime = 22,
  Numeric = 5,
  String = 1,
}

export interface SavVariable {
  name: string;
  short?: string;
  label: string;
  type: types;
  width: number;
  decimal: number;
  alignment?: alignments;
  measure?: measures;
  columns: number;
  valueLabels?: Array<{ label: string; value: string | number; }>;
}


export function toArray(variables, ncases, { bias }) {
  validate(variables);
  shortNames(variables);

  const arr: any = [
    fileHeaderRecord(variables, ncases, bias),
    variableRecord(variables),
    valueLabelsRecord(variables),
    machineIntegerInfoRecord(),
    machineFloatingPointInfoRecord(),
    variableDisplayParameterRecord(variables),
    longVariableNamesRecord(variables),
    longStringValueLabelsRecord(variables),
    characterEncodingRecord(),
    dictionaryTerminationRecord(),
  ];

  return arr.flat();
}

function characterEncodingRecord() {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 20 }, // subtype
    { type: BufferType.Int32, value: 1 }, // size
    { type: BufferType.Int32, value: 5 }, // count
    { type: BufferType.String, value: 'UTF-8' }, // encoding
  ];
}

function dictionaryTerminationRecord() {
  return [
    { type: BufferType.Int32, value: 999 }, // rec_type
    { type: BufferType.Int32, value: 0 }, // filler
  ];
}

function fileHeaderRecord(variables, ncases, bias) {
  return [
    { type: BufferType.String, value: '$FL2' }, // rec_type[4]
    { length: 60, type: BufferType.String, value: '@(#) SPSS DATA FILE - DingtalkSurvey' }, // prod_name[60]
    { type: BufferType.Int32, value: 2 }, // layout_code
    { type: BufferType.Int32, value: variables.map((v) => (v.type === types.String ? Math.ceil(v.width / 8) : 1)).reduce((a, b) => a + b) }, // nom_case_size
    { type: BufferType.Int32, value: 1 }, // compression
    { type: BufferType.Int32, value: 0 }, // weight_index
    { type: BufferType.Int32, value: ncases }, // ncases
    { type: BufferType.Float, value: bias }, // bias
    { type: BufferType.String, value: moment().format('DD MMM YY'), length: 9 }, // creation_date[9]
    { type: BufferType.String, value: moment().format('HH:mm:ss'), length: 8 }, // creation_time[8]
    { length: 64, type: BufferType.String, value: 'FILE GENERATED BY DingtalkSurvey' }, // file_label[64]
    { type: BufferType.Int8, value: 0 }, // padding
    { type: BufferType.Int8, value: 0 }, // padding
    { type: BufferType.Int8, value: 0 }, // padding
  ];
}

function longStringValueLabelsRecord(variables) {
  const valueLabels = buffer.write(variables.map((variable) => {
    if (!variable.valueLabels || !variable.valueLabels.length) return undefined;
    if (variable.type !== types.String || Math.ceil(variable.width / 8) === 1) return undefined;
    return [
      { type: BufferType.Int32, value: variable.short.length }, // var_name_length
      { type: BufferType.String, value: variable.short }, // var_name[]
      { type: BufferType.Int32, value: variable.width }, // var_width
      { type: BufferType.Int32, value: variable.valueLabels.length }, // n_labels
    ].concat(...variable.valueLabels.map(({ label, value }) => ([
      { type: BufferType.Int32, value: variable.width }, // value_len
      { length: variable.width, type: BufferType.String, value }, // value[]
      { type: BufferType.Int32, value: Buffer.byteLength(label, 'utf8') }, // label_len
      { type: BufferType.String, value: label }, // label[]
    ])));
  }).filter((valueLabel) => !!valueLabel).flat());
  return valueLabels.length ? [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 21 }, // subtype
    { type: BufferType.Int32, value: 1 }, // size
    { type: BufferType.Int32, value: valueLabels.length }, // count
    { type: BufferType.Buffer, value: valueLabels }, // var_value_labels[]
  ] : [];
}

function longVariableNamesRecord(variables) {
  const pairs = buffer.write(variables.map((variable) => [
    { type: BufferType.String, value: variable.short }, // var
    { type: BufferType.String, value: '=' }, // equals
    { type: BufferType.String, value: variable.name }, // name
    { type: BufferType.Int8, value: 9 }, // separator
  ]).flat().slice(0, -1));
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 13 }, // subtype
    { type: BufferType.Int32, value: 1 }, // size
    { type: BufferType.Int32, value: pairs.length }, // count
    { type: BufferType.Buffer, value: pairs }, // var_name_pairs[]
  ];
}

function machineFloatingPointInfoRecord() {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 4 }, // subtype
    { type: BufferType.Int32, value: 8 }, // size
    { type: BufferType.Int32, value: 3 }, // count
    { type: BufferType.Float, value: -Number.MAX_VALUE }, // sysmis
    { type: BufferType.Float, value: Number.MAX_VALUE }, // highest
    { type: BufferType.Float, value: -Number.MAX_VALUE }, // lowest
  ];
}

function machineIntegerInfoRecord() {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 3 }, // subtype
    { type: BufferType.Int32, value: 4 }, // size
    { type: BufferType.Int32, value: 8 }, // count
    { type: BufferType.Int32, value: 1 }, // version_major
    { type: BufferType.Int32, value: 2 }, // version_minor
    { type: BufferType.Int32, value: 0 }, // version_revision
    { type: BufferType.Int32, value: -1 }, // machine_code
    { type: BufferType.Int32, value: 1 }, // floating_point_rep
    { type: BufferType.Int32, value: 1 }, // compression_code
    { type: BufferType.Int32, value: 2 }, // endianness
    { type: BufferType.Int32, value: 65001 }, // character_code
  ];
}

function shortNames(variables) {
  variables.forEach((variable) => {
    let index = 0;
    let short = variable.name.toUpperCase().substring(0, 8);
    const shorts = variables.map((v) => v.short);
    while (shorts.includes(short)) {
      index += 1;
      short = `${short.slice(0, short.length - index.toString().length)}${index}`;
    }
    variable.short = short; // eslint-disable-line no-param-reassign
  });
}

function validate(variables) {
  variables.forEach((variable) => {
    if (!variable.name || !variable.name.length) throw new Error('Variable name can\'t be empty.');
    if (variable.name.length > 64) throw new Error('Variable name can\'t exceed 64 characters.');
    if (!variable.name.match(/^[a-z@][a-z0-9!._#@$]*[^.]$/i)) throw new Error('Variable name doesn\'t meet the SPSS requirements.');
    if (!variable.type) throw new Error('Variable type can\'t be empty.');
    Object.assign(variable,
      { alignment: variable.alignment || alignments.Right, label: variable.label || variable.name, measure: variable.measure || measures.Continuous });
    switch (variable.type) { // eslint-disable-line default-case
      case types.Date: Object.assign(variable, { columns: 10, decimal: 0, width: 10 }); break;
      case types.DateTime: Object.assign(variable, { columns: 19, decimal: 0, width: 19 }); break;
      case types.Numeric:
        Object.assign(variable, { decimal: variable.decimal === undefined ? 2 : variable.decimal, width: variable.width || 8 });
        Object.assign(variable, { columns: variable.columns || variable.decimal + variable.width });
        break;
      case types.String: Object.assign(variable, { columns:  variable.columns || variable.width || 8, decimal: 0, width: variable.width || 8 }); break;
    }
    if (variable.decimal < 0 || variable.decimal > 16) throw new Error('Variable decimal must be between 0 and 16.');
    if (variable.width < 0 || variable.width > 32767) throw new Error('Variable width must be between 0 and 32767.');
    if (variable.type !== types.String && variable.width > 40) throw new Error(`Variable width must be between 1 and 40 for type ${variable.type}.`);
    if (variable.width <= variable.decimal) throw new Error('Variable width can\'t be less or equal to variable decimal.');
  });
}

function valueLabelsRecord(variables) {
  let index = 0;
  return variables.map((variable) => {
    index += variable.type === types.String ? Math.ceil(variable.width / 8) : 1;
    if (!variable.valueLabels || !variable.valueLabels.length) return undefined;
    if (variable.type === types.String && Math.ceil(variable.width / 8) > 1) return undefined;
    return [
      { type: BufferType.Int32, value: 3 }, // rec_type
      { type: BufferType.Int32, value: variable.valueLabels.length }, // label_count
    ].concat(...variable.valueLabels.map(({ label, value }) => {
      let $label = label;
      let labelByteLength = Buffer.byteLength($label, 'utf8');

      while (labelByteLength > 255) {
        $label = label.substring(0, $label.length - 1);
        labelByteLength = Buffer.byteLength($label, 'utf8');
      }

      return [
        (variable.type === types.Numeric && { type: BufferType.Float, value: +value }) || { length: 8, type: BufferType.String, value }, // value[8]
        { type: BufferType.Int8, value: labelByteLength }, // label_len
        { length: roundUp(labelByteLength + 1, 8) - 1, type: BufferType.String, value: $label }, // label[]
      ];
    })).concat([
      { type: BufferType.Int32, value: 4 }, // rec_type
      { type: BufferType.Int32, value: 1 }, // var_count
      { type: BufferType.Int32, value: index }, // vars[]
    ]);
  }).filter((variable) => !!variable).flat();
}

function variableDisplayParameterRecord(variables) {
  return [
    { type: BufferType.Int32, value: 7 }, // rec_type
    { type: BufferType.Int32, value: 11 }, // subtype
    { type: BufferType.Int32, value: 4 }, // size
    { type: BufferType.Int32, value: variables.length * 3 }, // count
  ].concat(...variables.map((variable) => ([
    { type: BufferType.Int32, value: variable.measure }, // measure
    { type: BufferType.Int32, value: variable.columns }, // columns
    { type: BufferType.Int32, value: variable.alignment }, // alignment
  ])));
}

function variableRecord(variables) {
  return variables.map((variable) => {
    let label = variable.label;
    let labelByteLength = Buffer.byteLength(label, 'utf8');

    while (labelByteLength > 255) {
      label = label.substring(0, label.length - 1);
      labelByteLength = Buffer.byteLength(label, 'utf8');
    }

    return [
      { type: BufferType.Int32, value: 2 }, // rec_type
      { type: BufferType.Int32, value: variable.type === types.String ? variable.width : 0 }, // type
      { type: BufferType.Int32, value: variable.label && variable.label.length ? 1 : 0 }, // has_var_label
      { type: BufferType.Int32, value: 0 }, // n_missing_values
      { type: BufferType.Int32, value: variable.type * 65536 + variable.width * 256 + variable.decimal }, // print
      { type: BufferType.Int32, value: variable.type * 65536 + variable.width * 256 + variable.decimal }, // write
      { length: 8, type: BufferType.String, value: variable.short }, // name[8]
      { type: BufferType.Int32, value: labelByteLength }, // label_len
      { length: roundUp(labelByteLength, 4), type: BufferType.String, value: label }, // label[]
    ].concat(...variable.type === types.String ? Array.from({ length: Math.ceil(variable.width / 8) - 1 }).map(() => [
      { type: BufferType.Int32, value: 2 }, // rec_type
      { type: BufferType.Int32, value: -1 }, // type
      { type: BufferType.Float, value: 0 }, // ignored
      { type: BufferType.Float, value: 0 }, // ignored
      { type: BufferType.Float, value: 0 }, // ignored
    ]) : []);
  }).flat();
}

function roundUp(x, y) {
  return Math.ceil(x / y) * y;
}
